  

> Problem: [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)

  

[TOC]

  
![](SmartSelect_20240425_170548_Samsung%20Notes.jpg)
  

# Code

```C++ []

class Solution {

public:

    int findLength(vector<int>& nums1, vector<int>& nums2) {

        // dp[i][j] 表示nums1[0...i-1]和nums2[0...j-1]的最长重复子数组

        vector<vector<int>> dp(nums1.size() + 1,

                               vector<int>(nums2.size() + 1, 0));

        int res = 0;

        for (int i = 1; i < nums1.size()+1; i++) {

            for (int j = 1; j < nums2.size()+1; j++) {

                // 这里的i我们从1开始遍历，为了方便初始化

                // 所以这里比较相等是nums1[i-1]和nums2[j-1]

                // 得到如果子序列的最后一个数字相等

                // 我们取得i和j之前的最长重复子序列再+1

                if(nums1[i-1]==nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1;

                res=max(res,dp[i][j]);

            }

        }

        return res;

    }

};

```