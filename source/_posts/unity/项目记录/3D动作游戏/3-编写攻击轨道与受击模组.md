---
title: 3-编写攻击轨道与受击模组
date: 2024-05-07 10:04
tags:
---
## 攻击检测

使用**射线连续检测**攻击轨迹。

![](images/posts/Pasted%20image%2020240507142849.png)

![](images/posts/Pasted%20image%2020240507142845.png)

不仅仅是一条轨迹，可以定义**检测长度**、**检测密度**。

![](images/posts/Pasted%20image%2020240507161643.png)

但是现在是**离散的**，可以记录上一次**Direction**得到连续的射线。

![](images/posts/Pasted%20image%2020240507164424.png)

```cpp
private void OnDrawGizmos()  
{  
    if (CanDetection && Application.isPlaying && TargetTransform != null)  
        Debug.DrawLine(prePosition, TargetTransform.position, Color.red, 5f);  
    else if (!Application.isPlaying && DebugMode && TargetTransform != null)  
    {     if (prePosition != Vector3.zero)  
        {            Debug.DrawLine(prePosition, TargetTransform.position, Color.red, 5f);  
            var temp = Length / DetectionDensity;  
            for (int i = 0; i < DetectionDensity; i++)  
            {                var des = TargetTransform.position + TargetTransform.TransformDirection(Direction) * temp * i;  
                var desPre = prePosition + lastDiraction * temp * i;  
                Debug.DrawLine(desPre, des, Color.red, 5f);  
            }        }        prePosition = TargetTransform.position;  
        lastDiraction = TargetTransform.TransformDirection(Direction);  
    }}
```

定义攻击轨迹轨道，展示动作攻击轨迹。

## 受击盒子

采用在人物各个部位挂上Layer为HitBox作为受击盒子。在**运行时生成BoxCollider**并且更新对应位置。

![](images/posts/Pasted%20image%2020240507154209.png)

```cpp
public void Init()  
{  
    Collider = gameObject.AddComponent<BoxCollider>();  
    Collider.center = transform.InverseTransformPoint(center);  
    Collider.size = Box;  
}
public void Tick()  
{  
    if (Collider == null) return;  
    Collider.center = transform.InverseTransformPoint(center);  
}
```