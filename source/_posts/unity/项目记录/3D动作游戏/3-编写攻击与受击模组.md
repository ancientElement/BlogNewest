---
title: 3-编写攻击与受击模组
date: 2024-05-07 10:04
tags:
---
## 攻击检测

使用**射线连续检测**攻击轨迹。

![](images/posts/Pasted%20image%2020240507142849.png)

![](images/posts/Pasted%20image%2020240507142845.png)

不仅仅是一条轨迹，可以定义**检测长度**、**检测密度**。

![](images/posts/Pasted%20image%2020240507161643.png)

但是现在是**离散的**，可以记录上一次**Direction**得到连续的射线。

![](images/posts/Pasted%20image%2020240507164424.png)

主要逻辑代码：

```cpp
    if (prePosition != Vector3.zero)  
    {            
	    Debug.DrawLine(prePosition, TargetTransform.position, Color.red, 5f);  
		var temp = Length / DetectionDensity;  
		for (int i = 0; i < DetectionDensity; i++)  
		{                
			var des = TargetTransform.position + TargetTransform.TransformDirection(Direction) * temp * i;  
			var desPre = prePosition + lastDiraction * temp * i;  
			Debug.DrawLine(desPre, des, Color.red, 5f);  
		}        
	}        
	prePosition = TargetTransform.position;  
	lastDiraction = TargetTransform.TransformDirection(Direction);  
```

## 受击盒子

采用在人物各个部位挂上Layer为HitBox作为受击盒子。在**运行时生成BoxCollider**并且更新对应位置。

![](images/posts/Pasted%20image%2020240507154209.png)

```cpp
public void Init()  
{  
    Collider = gameObject.AddComponent<BoxCollider>();  
    Collider.center = transform.InverseTransformPoint(center);  
    Collider.size = Box;  
}
public void Tick()  
{  
    if (Collider == null) return;  
    Collider.center = transform.InverseTransformPoint(center);  
}
```

## 攻击特效