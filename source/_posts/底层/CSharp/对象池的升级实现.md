---
title: 对象池的升级实现
date: 2023-03-06T15:33:00
tags:
  - 随手记
  - 所想
---
我们可以实现一个类,`PoolObj<T>`,并且实现一个**Get方法**、和**Recycle方法**。

> 那么我们如何防止使用者用new 来创建呢？
> 好像不行，无参构造函数私有之后外部就无法创建他了


```C#
public class PoolObj<T> where T : new()
{
	public static T GetObject()
	{
		return PoolMgr.GetObj<T>();
	}

	public static void ReturnObject(T obj)
	{
		PoolMgr.Push<T>();
	}
}
```


## 对象池的弊端

1. **内存消耗**：对象池需要在内存中**保存一定数量**的对象实例，这可能会增加内存消耗，特别是在对象较大或者数量较多的情况下。
    
2. 对象管理复杂性：对象池需要额外的逻辑来管理对象的获取、释放和重用，这可能增加代码的复杂性和维护成本。
    
3. **线程安全性**：在多线程环境下，对象池的实现可能需要考虑线程安全性，以避免多线程访问时出现**竞争条件**或者**死锁**等问题。
    
4. 性能开销：对象池可能会引入额外的性能开销，例如对象的获取和释放操作可能会涉及到较多的内存分配和释放操作，以及对象池本身的管理逻辑可能会引入一定的性能开销。
    
5. 对象泄漏：如果对象池的实现不正确，可能会导致**对象泄漏**的问题，即对象被获取后没有正确释放，导致对象池中的对象数量不断增加，最终影响性能和内存消耗。

尽管存在一些弊端，但对象池在一些场景下仍然是一个有效的解决方案，特别是在需要频繁创建和销毁对象的情况下，通过对象池可以减少对象的创建和销毁次数，提高性能和资源利用率。因此，在使用对象池时，需要综合考虑项目的实际需求和场景特点，合理权衡利弊。